# Cellular Automata Simulator

This project aims to develop a versatile, rule-based simulation engine for grid-based systems. It is designed to support various cellular automata, including classic examples like Wireworld, and to generate training data for advanced AI tasks such as ARC-AGI. A key feature is the ability to infer underlying rules from observed "before" and "after" grid transformations, providing a feedback loop for iterative improvement.

## Key Features

  - **Customizable Rule Sets:** Define complex cellular automaton behaviors using a simple, human-readable YAML format.
  - **Deterministic Simulation:** Ensures consistent and predictable outcomes for given initial states and rule sets.
  - **Caching for Performance:** Optimize simulations by storing and reusing results of previously computed grid states.
  - **Interactive Grid Editor:** Visually design initial grid configurations for simulations and puzzles.
  - **Rule Inference Module:** Automatically generate and refine rule sets from "before" and "after" image pairs, facilitating training data creation for AI.
  - **Puzzle Game Design:** Enable users to create and solve grid-based puzzle games (e.g., XOR/NAND gates in Wireworld).
  - **Iterative Improvement Loop:** Evaluate inferred rules against target outcomes to drive continuous refinement.

## High-Level Architecture

The system is composed of several interconnected modules that manage rule definition, simulation execution, user interaction, and rule inference.

1.  **User Interface (UI)**

      - **Purpose:** Provides the primary interface for users to interact with the simulator.
      - **Functionality:**
          - **Grid Editor:** Visual tool for creating and modifying initial grid states.
          - **Rule Editor:** Allows defining and managing rule sets, supporting both direct YAML editing and a graphical pattern builder.
          - **Simulation Controls:** Play, pause, step, reset, and speed adjustments for simulations.
          - **Visualization:** Displays the grid's evolution in real-time and presents "before" and "after" states for rule inference.
      - **Interactions:** Sends grid states and rule sets to the **Simulation Engine**. Sends "before/after" pairs to the **Rule Inference Module**. Receives updated grid states and inference results for display.

2.  **Rule Definition Language (RDL)**

      - **Purpose:** A formal, YAML-based language for precisely describing cellular automaton rules.
      - **Structure:** Defines Left-Hand Side (LHS) patterns (e.g., 3x3 cell configurations, including wildcards), optional conditions based on neighbor counts, and Right-Hand Side (RHS) transformations (the new state of the center cell).
      - **Interactions:** Generated and parsed by the **UI's Rule Editor**. Interpreted by the **Simulation Engine**. Generated by the **Rule Inference Module**.

3.  **Simulation Engine**

      - **Purpose:** Executes the cellular automaton rules on a given grid state.
      - **Functionality:**
          - **Grid Manager:** Maintains two grid buffers (current and next state) to ensure synchronous updates.
          - **Rule Application Logic:** Iterates through each cell, identifies matching RDL patterns, and applies the corresponding transformations to the "next" grid buffer.
          - **Caching Layer:** Stores hashes of grid states and their resulting next states to optimize performance by avoiding redundant computations.
      - **Interactions:** Receives rule sets and initial grids. Provides updated grids for visualization. Used by the **Rule Inference Module** to test candidate rule sets.

4.  **Rule Inference Module**

      - **Purpose:** Automatically generates and refines rule sets from observed grid transformations.
      - **Functionality:**
          - **Difference Analyzer:** Identifies changes between "before" and "after" grids to pinpoint areas of transformation.
          - **Hypothesis Generator:** Proposes candidate `LHS :> RHS` rules based on the detected changes, initially focusing on localized patterns.
          - **Evaluation Orchestrator:** Uses the **Simulation Engine** to run candidate rule sets on "before" grids and compares the simulated "after" state to the target "after" state using the **Evaluation Module**.
          - **Refinement Loop:** Iteratively adjusts and optimizes rule sets based on the calculated difference scores.
      - **Interactions:** Receives "before/after" grid pairs. Interacts with the **Simulation Engine** for rule testing. Provides inferred rules and performance metrics.

5.  **Evaluation Module**

      - **Purpose:** Quantifies the accuracy and quality of generated or inferred rule sets.
      - **Functionality:**
          - **Difference Metric Calculator:** Computes similarity scores between simulated and target "after" grids. This includes pixel-by-pixel comparisons and potentially more advanced feature-based comparisons (e.g., object continuity for ARC tasks).
      - **Interactions:** Provides feedback to the **Rule Inference Module** to guide rule refinement.

## Rule Definition (YAML Format)

Rules are defined in a YAML file, specifying the automaton's properties and a list of transformation rules. Each rule includes a pattern (LHS), optional conditions, and a new state (RHS) for the center cell.

### Example: Wireworld Rules (`wireworld_rules.yaml`)

```yaml
name: Wireworld
description: Classic cellular automaton simulating electron flow.
grid_dimensions: 2D
neighborhood: moore # Defines an 8-neighbor (3x3) neighborhood, including the center cell.
neighborhood_size: 3x3 # The size of the pattern to match, centered on the cell being updated.
states:
  empty: 0
  electron_head: 1
  electron_tail: 2
  conductor: 3

rules:
  - name: Head to Tail
    description: An Electron Head always becomes an Electron Tail.
    pattern: # The 3x3 pattern for the Left-Hand Side (LHS). 'X' is a wildcard.
      - [X, X, X]
      - [X, 1, X] # Center cell must be an Electron Head (state 1)
      - [X, X, X]
    new_state: 2 # The center cell becomes an Electron Tail (state 2)

  - name: Tail to Conductor
    description: An Electron Tail always becomes a Conductor.
    pattern:
      - [X, X, X]
      - [X, 2, X] # Center cell must be an Electron Tail (state 2)
      - [X, X, X]
    new_state: 3 # The center cell becomes a Conductor (state 3)

  - name: Conductor to Head
    description: A Conductor becomes an Electron Head if it has 1 or 2 Electron Heads in its neighbors.
    pattern:
      - [X, X, X]
      - [X, 3, X] # Center cell must be a Conductor (state 3)
      - [X, X, X]
    conditions: # Conditions applied to the neighbors of the center cell
      - type: neighbor_count
        state: 1 # Count Electron Heads (state 1) among neighbors
        operator: in # The count must be one of the specified values
        values: [1, 2] # Exactly 1 or 2 Electron Heads
    new_state: 1 # The center cell becomes an Electron Head (state 1)

  - name: Default Conductor (no change if conditions not met)
    description: A Conductor remains a Conductor if it does not meet the criteria to become an Electron Head.
    pattern:
      - [X, X, X]
      - [X, 3, X] # Center cell must be a Conductor (state 3)
      - [X, X, X]
    conditions:
      - type: neighbor_count
        state: 1 # Count Electron Heads (state 1) among neighbors
        operator: not in # The count must NOT be one of the specified values
        values: [1, 2] # Not 1 or 2 Electron Heads
    new_state: 3 # The center cell remains a Conductor (state 3)

  - name: Default Empty (no change)
    description: An Empty cell always remains Empty.
    pattern:
      - [X, X, X]
      - [X, 0, X] # Center cell must be Empty (state 0)
      - [X, X, X]
    new_state: 0 # The center cell remains Empty (state 0)
```

## Technical Stack

  - **Core Logic:** Python
  - **Initial UI (v1):** Text-based User Interface (TUI) library (e.g., `curses` or `rich` for a more modern look).
  - **Future UI (v2):** PyQt for a robust, desktop-grade graphical user interface.

## Future Enhancements

  - **Advanced Caching:** Implement more sophisticated caching strategies, such as run-length encoding for sparse grids or identifying "still life" patterns.
  - **Optimized Rule Matching:** Explore techniques like decision trees or compiled rule sets for faster pattern matching.
  - **Parallel Rule Application:** Investigate parallelization strategies for rule application while maintaining determinism (e.g., using a "new state buffer" for each cell).
  - **Expanded RDL:** Introduce support for variable-sized patterns, non-rectangular neighborhoods, and more complex conditional logic.
  - **Sophisticated Rule Inference:** Incorporate machine learning techniques (e.g., genetic algorithms, neural networks) to infer more abstract and complex rule sets.
  - **Domain-Specific Optimizations:** Tailor performance for specific cellular automata types (e.g., Conway's Game of Life, Wireworld) if general optimizations are insufficient.
  